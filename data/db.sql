/*==========================================
* CREATION DE LA BDD JARDIN
========================================= */

BEGIN;
-- Note : BEGIN déclare le début d'une transaction : un groupe d'instructions SQL qui rend celles-ci dépendantes les unes des autres. 
-- Si au moins une des instructions génère une erreur, alors toutes les commandes sont invalidées.

--Suppression des tables existantes
DROP TABLE IF EXISTS carres CASCADE,
                     legumes CASCADE,
                     composition_legumes CASCADE,
                     familles CASCADE,
                     historique CASCADE;

/*
Notes :
  - id : 
    - La clé primaire est automatiquement NOT NULL. Pas besoin de le préciser.
    - On spécifie que la colonne sera générée automatiquement par la BDD en suivant une séquence numérique prédéfinie, s'incrémentant de 1 en 1.
    - On peut définir 'BY DEFAULT' (surcharge de la valeur possible) ou 'ALWAYS' (surcharge de la valeur impossible)
    - Ici on utilise BY DEFAULT, car on définit nous même les valeurs des clés primaires (dans le fichier de seeding).
    - Mais on utilisera plus généralement ALWAYS afin de sécurisé l'incrémentation des valeurs du champ
    - created_at 
    - CURRENT_TIMESTAMP : on peut aussi utiliser now()
*/

-- Creation des tables
CREATE TABLE IF NOT EXISTS familles (
  id SERIAL PRIMARY KEY,                       -- ou "id" integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  type VARCHAR(100) UNIQUE,
  commentaire TEXT
  "created_at" timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" timestamptz
);

CREATE TABLE IF NOT EXISTS legumes (
  id SERIAL PRIMARY KEY,
  nom VARCHAR(100) UNIQUE NOT NULL,
  variete VARCHAR(100),
  type VARCHAR(100) REFERENCES familles(type),  
  alliances VARCHAR(100)[],
  "created_at" timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" timestamptz
  FOREIGN KEY (type) REFERENCES familles(type)
);

CREATE TABLE IF NOT EXISTS carres (
  id SERIAL PRIMARY KEY,
  disponible BOOLEAN NOT NULL,
  composition VARCHAR(100)[],   
  annee DATE NOT NULL,
  commentaire TEXT
  "created_at" timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" timestamptz
);

CREATE TABLE IF NOT EXISTS composition_legumes (
  id SERIAL PRIMARY KEY,
  carre_id INTEGER REFERENCES carres (id),
  legume_nom VARCHAR(100) REFERENCES legumes (nom),
  "created_at" timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" timestamptz
  FOREIGN KEY (carre_id) REFERENCES carres (id),
  FOREIGN KEY (legume_nom) REFERENCES legumes (nom)
);

CREATE TABLE IF NOT EXISTS historique (
  id SERIAL PRIMARY KEY,
  annee DATE NOT NULL,
  carre INTEGER REFERENCES carres(id),
  composition VARCHAR(100)[],
  "created_at" timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" timestamptz
  FOREIGN KEY (carre) REFERENCES carres(id)
);

/*==========================================
* Insertion des données
========================================= */

-- TENIR COMPTE DES CONTRAINTES POUR L'ORDRE DE CREATION
INSERT INTO familles (type, commentaire)
VALUES 
  ('Feuilles', 'choux, salades (laitues, chicorées, mâches…), épinard…'),
  ('Racines', 'carotte, betterave, navet, radis, pomme de terre…'),
  ('Graines', 'fèves, haricots, pois ou engrais vert'),
  ('Fruits', 'tomate, courgette, aubergine, potiron, concombre, cornichon…'),
  ('Bulbes', 'poireau, ail, oignon, échalote…');

INSERT INTO legumes (nom, variete, type, alliances)
VALUES 
  ('Bettrave', '' , 'Racines', '{chou, céleri, laitue, oignon}'),
  ('Poireaux', '' , 'Bulbes', '{carotte, céleri}'),
  ('Courgette', '' , 'Fruits', '{basilic, haricot, maïs, persil}'),
  ('Radis', '' , 'Racines', '{haricot, laitue, pois}'),
  ('Haricots vert', '' , 'Graines', '{carotte, céleri, maïs, fraisier}'),
  ('Tomate', '' , 'Fruits', '{basilic, carotte, oignon, persil}'),
  ('Salade', '' , 'Feuilles', '{carotte, céleri, oignon, pois}'),
  ('Pomme de terre', '' , 'Racines', '{brocoli, chou-fleur, épinard, haricot, pois}');

INSERT INTO carres (disponible, composition, annee, commentaire)
VALUES 
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', ''),
  (True, ARRAY[]::VARCHAR(100)[], '2023-01-01', '');

INSERT INTO composition_legumes (carre_id, legume_nom)
VALUES 
  (1, 'Poireaux'),
  (1, 'Bettrave');

UPDATE carres
SET composition = (SELECT ARRAY_AGG(legume_nom) FROM composition_legumes WHERE carre_id = 1)
WHERE id = 1;



COMMIT; -- Pour mettre fin à au bloc de transaction et l'exécuter